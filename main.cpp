#include <iostream>
#include <windows.h>

using namespace std;


//Напишите рекурсивную функцию вычисления наибольшего общего делителя двух положительных целых чисел (Greatest Common Divisor, GCD). Для этого воспользуйтесь следующими свойствами:
//
//GCD(a, b) = GCD(b, a \bmod b)GCD(a,b)=GCD(b,amodb)
//GCD(0, a) = aGCD(0,a)=a
//        GCD(a, b) = GCD(b, a)GCD(a,b)=GCD(b,a)
//Требования к реализации: в данном задании запрещено пользоваться циклами. Вы можете заводить любые вспомогательные функции, если они вам нужны. Функцию main определять не нужно.

unsigned gcd(unsigned a, unsigned b) {
    if (a == 0) return b;
    if (b == 0)return a;

    if (a > b) {
        return gcd(b, a % b);
    }

    return gcd(b, a % b);
}

int foo(int n) {
    cout << "1" << endl;
    if (n <= 0)
        return 1;
    return foo((n * 2) / 3) + foo(n - 2);
}

void recursion(int i) {
    if (i == 0)return;
    int a;
    cin >> a;
    recursion(a);
    cout << i << " ";
}

void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void rotate(int a[], unsigned size, int shift) {
    for (int n = 0; n < shift; n++) {
        for (int i = 0; i < size - 1; i++) {
            swap(&a[i], &a[(i + 1) % size]);
        }
    }
}

// В этой задаче вам нужно реализовать функцию, которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).
// На вход функция принимает массив, его размер и величину сдвига. Например, если на вход функции подан массив: int a[] = { 1, 2, 3, 4, 5 }; и требуется циклически сдвинуть его влево на 2 позиции, то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.
// Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.
// Требования к реализации: вам нужно реализовать только функцию циклического сдвига. При этом она не должна вводить или выводить что-либо. При решении этой задачи вы можете определять любые вспомогательные функции, если они вам нужны. Реализовывать функцию main не нужно. Предполагается, что вам не потребуется дополнительная память, а именно: массивы и стандартные контейнеры. Пользоваться стандартными алгоритмами и контейнерами не разрешается, даже если вы с ними знакомы.
// Рекомендация: перед тем, как начать кодировать решение этой задачи, продумайте алгоритм, который вы будете использовать. В данной задаче не проверяется эффективность этого алгоритма (в разумных пределах).
// Подсказка: вам может потребоваться оператор % для вычисления остатка. Наиболее простая реализация этой функции сдвигает массив на один элемент за проход. Наиболее простая реализация несколько раз использует функцию, которая переставляет элементы массива в обратном порядке.

int main() {
    SetConsoleOutputCP(CP_UTF8);

    int arr[] = {1, 4, 3, 5};
    for (int i = 0; i < (sizeof(arr) / sizeof(*arr)); i++) {
        cout << arr[i] << endl;
    }

    rotate(arr, 4, 2);

    cout << "########" << endl;

    for (int i = 0; i < (sizeof(arr) / sizeof(*arr)); i++) {
        cout << arr[i] << endl;
    }

    return 0;
}
